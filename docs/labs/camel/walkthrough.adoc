:walkthrough: Lab Introduction
:user-password: openshift
:namespace: {user-username}

:experimental:

:article-url: https://developers.redhat.com/articles/2023/03/09/try-camel-k-developer-sandbox
// URLs
:codeready-url: http://codeready-che.{openshift-app-host}/

ifdef::env-github[]
endif::[]

[id='lab-intro']
= Camel - User Demo

Use Camel's fast prototyping using low-code UI and commands to build your integration flows and deploy them on OpenShift.

// Walk your first steps with Camel K by creating and running your first integration service that integrates with a legacy backend.

This hands-on lab is based on the following blog article in Red Hat Developers:

* link:{article-url}[window="_blank", , id="rhd-source-article"]

{empty} +

The sequence diagram below illustrates the flow you're about to create.

image::images/seq-diagram.png[align="center", width=40%]

{empty} +

The Camel integration will expose an HTTP entry point, and upon client requests, it'll fetch XML data from a (simulated) legacy backend, transform its response into JSON, and return it to the client application.

Assuming you have followed the article's instructions, you should be all set to get hands-on with _Camel_ in the _OpenShift Dev Spaces_ workspace.

{empty} +


[time=1]
[id="introduction"]
== Introduction

If you haven't used _Apache Camel_ before, or haven't played with recent versions and tools, it's important you read below all the pieces that are at play, and understand they are conceived to converge into providing a unified development experience.

To briefly introduce the set of tools you're about to use, here's a list of the components that will help you along the way:

- *Dev Spaces / VSCode*: the IDE you'll be using to create the _Camel_ processes.
- *Apache Camel*: the integration framework you'll use packed with Enterprise Integration Patterns and Components (connectors).
- *Kaoto*: visual editor for _Apache Camel_ to create your _Camel_ routes and processes in VS_Code.
- *Camel JBang*: _Camel_ CLI (command line interface) designed to boost prototyping and accelerate your work to create, test and deploy your applications.
- *Quarkus*: The runtime used by _Camel_ to deploy your integration processes on _OpenShift_
- *OpenShift*: _Kubernetes_ environment where you will deploy your _Camel_ project.

{empty} +

=== No Java

One big highlight of the exercises you're about to embark on is that although _Apache Camel_ is _Java_ based, you won't see a single line of _Java_, nor have to define or manage dependencies. Those concerns are kept hidden to allow the developer become more productive by focussing on the business case at hand.

NOTE: It goes without saying that at any moment in time _Java_ code can be injected within your _Apache Camel_ processes to incorporate the custom handling you need. _Apache Camel_ excels in this respect thanks to its open framework architecture and extensibility.

{empty} +


[time=2]
[id="preparations"]
== Lab Preparations

Before we start real work, let's prepare some equipment before riding the _Camel_.

{empty} +

. Toggle auto-save off
+
You'll be making live code changes which _Camel_ can pick up in real time. You need to ensure the changes do not trigger a reload every time you press a key, but only when you manually save your changes.
+
image::images/autosave.png[align="left", width=30%]
+
WARNING: The auto-save option in the menu does not always show when it's active/inactive. If you see in your editor's file tab a permanent white dot `⭘` when you make changes, it means auto-save is OFF.
+
{empty} +

. Open your terminal
+
Make sure you make visible your terminal in the IDE. You can toggle it using the keyboard keys kbd:[Ctrl + `] or simply find the option from the menu system as per the picture below:
+
image::images/toggle-terminal.png[align="left", width=40%]

. Create a working folder
+
Execute the commands below to create a new directory from where you can work and is visible in your project explorer:
+
[source, subs=]
----
mkdir lab
cd lab
<br>
----
+
{empty} +

. Set your working project in _OpenShift_
+
Make sure your CLI `oc` client (_OpenShift_ client) points to your personal _Developer Sandbox_ project (aka namespace):
+
[source, subs=]
----
oc project $WORKSPACE_NAMESPACE<br>
----
+
NOTE: The _Developer Sandbox_ only allows 1 project (namespace) per user.
+
The command above should output something similar to:
+
----
Already on project "<your-username>--dev" on server "https://172.30.0.1:443".
----
+
{blank}
+
WARNING: Not specifying your target project (namespace) in _OpenShift_ may result in a deployment failure.
+
{empty} +


You're now all set and ready start riding the _Camel_.

{empty} +


[time=8]
[id="development"]
== Fast Prototyping

This section shows you to prototype your project in fast iteration cycles. _Camel JBang's_ provides a *'developer mode'* that allows it to detect and apply on-the-fly any changes you perform.

To make the example interesting, the service you will create will operate as an adaptation layer, collecting data in XML format from a remote server and transforming it to JSON. This is a very typical use case where modern API façades serve data obtained from legacy systems.

{empty} +

. Create your integration definition
+
To swiftly create a skeleton _Camel_ route definition, we can use the `camel` client ( link:https://camel.apache.org/manual/camel-jbang.html[_Camel JBang_, window="_blank", id="camel-jbang"] client) from the terminal. Execute the following command:
+
[source, subs=]
----
camel init user.camel.yaml<br>
----
+
{blank}
+
The above command initialises a YAML-based _Camel_ definition. Other languages, like Java and XML, are also supported.
+
{empty} +

. Open the route in the visual editor
+
You'll find your newly created integration file under the following path in your project explorer:
+
--
* `lab/user.camel.yaml`
+
{empty}
+
image::images/camel-route-users.png[align="left", width=30%]
+
NOTE: Ignore other _Camel_ resources (folders) in the project tree,  they belong to other lab tutorials included in the same _GitHub_ repository.
--
+
{blank}
+
Click on the _Camel_ source file to display it in _Kaoto_ (_Camel_'s visual editor).
+
image::images/camel-route-users-kaoto.png[align="left", width=80%]
+
The visual editor will show you the default _Camel_ route initialised in step 1, consisting in a timer-to-log processing flow that generates an event every second. Each execution defines a payload (body) and writes it to log.
+
{empty} +


. Run the integration in *'developer mode'*:
+
[source, subs=]
----
camel run * --dev<br>
----
+
NOTE: the `*` indicates to load all source files in the folder. the `--dev` flag activates the developer mode.
+
{blank}
+
After Camel finishes the start up phase, you'll see a new trace every second, similar to:
+
----
2024-10-24 07:21:27.941  INFO ... : Hello Camel from route1
2024-10-24 07:21:28.941  INFO ... : Hello Camel from route1
2024-10-24 07:21:29.941  INFO ... : Hello Camel from route1
----
+
{empty} +


. Start making changes in the _Camel_ route. 
+
Because you're running _Camel_ in developer mode, every change you do in the editor will trigger a hot-reload and automatic restart.
+
Update the `timer` definition. +
Look at the figure below and follow these steps:
+
--
. Click the timer activity to open the configuration pane.
. Click kbd:[All] (properties).
. Use the filter `repeat` to search and find properties.
. Set the `repeatCount` property to 1.
. Close the configuration pane.
--
+
image::images/kaoto-timer-update.png[align="left", width=50%]
+
{blank}
+
In the logs, you will see Camel react by restarting and executing the route only once, because `repeatCount` was set to 1:
+
----
2024-10-24 10:22:23.443  INFO ... : Routes reloaded summary (total:1 started:1)
2024-10-24 10:22:23.443  INFO ... :     Started route-4178 (timer://yaml) (source: user.camel.yaml:4)
2024-10-24 10:22:24.442  INFO ... : Hello Camel from route-4178
----
+
{empty} +

. Define an HTTPS call
+
.. Copy the endpoint URL below:
+
[source, subs=]
----
https://random-data-api.com/api/v2/users?response_type=xml
----
+
NOTE: The parameter `response_type` tells the server to return the data in XML format.
+
.. Look at the figure below and follow these steps:
+
--
. Click the 3 dots kbd:[*⋮*] in `setBody`.
. Click kbd:[Replace].
. Use the filter `https` to search and find the component.
. Select the HTTPS component.
. Click on the HTTPS step.
. Paste the URL (you copied above) in the `Http Uri` property.
. Close the configuration pane.
--
+
image::images/kaoto-https.png[align="left", width=100%]
+
{blank}
+
In the logs, you will see _Camel_ reacting and fetching an XML response from the backend, similar to the sample lot traces below:
+
----
Routes reloaded summary (total:1 started:1)
    Started route-4178 (timer://yaml) (source: user.camel.yaml:4)
<?xml version="1.0" encoding="UTF-8"?>
<hash>
  ...
  <username>jackqueline.mosciski</username>
  <email>jackqueline.mosciski@email.com</email>
  ...
----
+
{empty} +

. Define an HTTP listener
+
Now, expose the process as a service. Replace the Timer event producer with an HTTP listener.
+
Look at the figure below and follow these steps:
+
--
. Click the 3 dots kbd:[*⋮*] in `timer`.
. Click kbd:[Replace].
. Use the filter `platform-http` to search and find the component.
. Select the *Platform HTTP* card.
. Click on the `platform-http` step.
. Set the Path property with `/user`.
. Close the configuration pane.
--
+
image::images/kaoto-platform-http.png[align="left", width=100%]
+
{blank}
+
In the logs, you will see _Camel_ reacting and fetching an XML response from the backend, similar to the sample lot traces below:
+
----
Routes reloaded summary (total:1 started:1)
    Started route-4178 (timer://yaml) (source: user.camel.yaml:4)
<?xml version="1.0" encoding="UTF-8"?>
<hash>
  ...
  <username>jackqueline.mosciski</username>
  <email>jackqueline.mosciski@email.com</email>
  ...
----
+
{empty} +

. Clean incoming HTTP headers
+
To ensure the process cleanly calls the HTTP endpoint and to prevent header propagation, you need to include a step to clean the incoming HTTP headers.
+
Look at the figure below and follow these steps:
+
--
. Click the 3 dots kbd:[*⋮*] in `platform-http`.
. Click kbd:[+ Add step].
. Use the filter `removeheaders` to search and find the component.
. Select the *Remove Headers* card.
. Click on the `removeHeaders` step.
. Set the Pattern property to `*`.
. Close the configuration pane.
--
+
image::images/kaoto-remove-headers.png[align="left", width=100%]
+
{blank}
+
At this point your Camel route should look in Kaoto as the picture below:
+
image::images/kaoto-flow-phase-1.png[align="left", width=50%]
+
{blank}
+
In the logs, you should see _Camel_ having reacted from the updates above and showing the following traces:
+
----
... : Routes reloaded summary (total:1 started:1)
... :     Started route-4178 (platform-http:///user) (source: user.camel.yaml:5)
----
+
{empty} +

. Test the listener
+
To validate what you've done so far, test the listener from a new terminal. Choose the _Split_ option from the current terminal's top right corner, as shown below:
+
image::images/terminal-split.png[align="left", width=30%]
+
{blank}
+
From the new terminal, run the following cURL command to test your service:
+
[source, subs=]
----
curl -s http://localhost:8080/user | bat -pP -lxml<br>
----
+
NOTE: The command also includes a pipe to colorize the XML output for better reading.
+
The invocation should return an XML header similar to:
+
----
<?xml version="1.0" encoding="UTF-8"?>
<hash>
  <id type="integer">8077</id>
  <uid>1d2f4251-deec-4208-a21a-166cf631c061</uid>
  <password>9lJ6UGqIZE</password>
  ...
----
+
{blank}
+
So far so good.
+
{empty} +

. Apply XML to JSON transformation
+
Keep iterating the prototype by introducing XML to JSON translation.
+
In _Camel_ there are many strategies available to convert XML into JSON. In this case you will use the _Marshal/Unmarshal_ EIP to update the flow. You do it by adding two extra steps to the process: first _Unmarshal_ (XML) and then _Marshal_ (JSON).
+
====
.. Start by unmarshalling the XML data +
+
Look at the figure below and follow these steps:
+
--
. Right-click on the `https` step.
. Select the  kbd:[Append] option.
. Use the filter `unmarshal` to search and find the component.
. Select the *Unmarshal* card.
. Click on the `unmarshal` step.
. Select the *Jackson XML* Data Format.
. Close the configuration pane.
--
+
image::images/kaoto-unmarshal-xml.png[align="left", width=100%]
+
.. Then marshal to JSON
+
Look at the figure below and follow these steps:
+
--
. Right-click on the `unmarshal` step.
. Select the  kbd:[Append] option.
. Use the filter `marshal` to search and find the component.
. Select the *Marshal* card.
. Click on the `unmarshal` step.
. Select the *Json* Data Format.
. Close the configuration pane.
--
+
image::images/kaoto-marshal-json.png[align="left", width=100%]
+
{blank}
====
+
At this point your Camel route should look in Kaoto as the picture below:
+
image::images/kaoto-flow-phase-2.png[align="left", width=50%]
+
{blank}
+
In the logs, you should see _Camel_ having reacted from the updates above and showing the following traces:
+
----
... : Routes reloaded summary (total:1 started:1)
... :     Started route-4178 (platform-http:///user) (source: user.camel.yaml:5)
----
+
{empty} +

. Test the XML to JSON transformation
+
Test the Unmarshal/Marshal steps with the command below:
+
[source, subs=]
----
curl -s http://localhost:8080/user | jq<br>
----
+
NOTE: The command also includes a pipe to colorize the JSON output for better reading.
+
The invocation should return JSON data, similar to:
+
----
{
  "phone-number": "+63 890.053.3511 x6876",
  "address": {
    "city": "Feestport",
    "street-name": "Cecil Camp",
    "street-address": "12806 Abbott Summit",
  ...
----
+
{empty} +

{empty} +

[type=verification]
Did your last curl command return JSON data?

[type=verificationSuccess]
Well done !!

[type=verificationFail]
Go back in your footsteps and review the actions.


[time=4]
[id="deploy-integration"]
== Deploy your integration

You've completed your prototype, it is time to deploy it. +
The _Camel_ CLI (_Camel JBang_) includes a _Kubernetes_ plugin that makes it very easy to deploy your application on Openshift.

Camel JBang and the _Kubernetes_ plugin will do all the work for you. Your code gets analysed and all the necessary dependencies automatically detected and downloaded, then containerised and deployed on Openshift.

Follow the commands below:

. If you haven't done so already, stop Camel with kbd:[Ctrl+c].
. Run the following command from your terminal to deploy your application:
+
[source, subs=]
----
camel kubernetes run * --cluster-type=openshift
----
+
NOTE: The `--cluster-type` flag indicates the _Kubernetes_ flavour of your target environment.

{empty} +

Running the `kamel` client with the `--dev` flag (dev mode) showed you in the previous chapter how to hook your terminal with the running pod  (dev mode) in the _Developer Sandbox_. Now you will deploy your integration detached from your IDE.

. Execute the deployment command
+
All it takes to deploy your integration is to remove the `--dev` flag. +
Copy and paste the command below to push the integration to the _Developer Sandbox_:
+
[source, subs=]
----
kamel run user.xml \
-d camel-jackson \
-d camel-jacksonxml<br>
----
+
{blank}
+
What really happens behind the scenes when executing the command above is that the `kamel` client converts your source code into an _Integration_ CRD (Custom Resource Definition) defined in YAML and then pushes it to the _Developer Sandbox_.
+
It is the _Camel K_ operator, not visible to you, running in the _Developer Sandbox_, that picks up the CRD and triggers a build and deploys it.
+
{empty} +

. Visualise your pod
+
If you switch to your _Developer Sandbox_ topology view, you'll see the pod running again, only this time is not hooked to your terminal:
+
image::images/pod-user-knative.png[align="left", width=20%]
+
{empty} +

. Use the CLIs to confirm
+
You can use your terminal to obtain information about your running integration.
+
Using your `kamel` client, execute:
+
[source, subs=]
----
kamel get<br>
----
+
{blank}
+
Which should return something similar to:
+
----
NAME    PHASE   KIT
user    Running camel-k-operator/kit-ceu0v85mq41b5tocq4sg
----
+
{empty} +
+
Using your `oc` client (_OpenShift_ client), execute:
+
[source, subs=]
----
oc get integration<br>
----
+
{blank}
+
Which should return something similar to:
+
----
NAME   PHASE     KIT                        REPLICAS
user   Running   kit-ceu0v85mq41b5tocq4sg   1
----
+
{empty} +

. Invoke the service as an external client
+
You can notice, from your topology view, your pod showing a small icon to open the URL exposed by the service:
+
image::images/pod-user-route.png[align="left", width=25%]
+
Click on it.
+
If your browser renders “Resource not found” or another error message, make sure your address bar uses HTTP (not HTTPS), and you include the service path ‘/user’ at the end of the URL, something similar to:
+
--
* `**http://**…(long address value here)...**/user**`
--
+
{blank}
+
In your browser, you should see user data in JSON format, similar to:
+
image::images/user-http-response.png[align="center", width=100%]
+
You can also obtain the route details with the following command and use its URL from your favourite local HTTP client/tester, like _Postman_, _Swagger_ or others.
+
[source, subs=]
----
kn route list -o jsonpath={.items[?(@.metadata.name==\"user\")].status.url}<br>
----
+
{blank}
+
Embedding the `kn` command in a cURL allows you to invoke the service as an external consumer.
+
--
* Copy/paste the following cURL command to simulate an external call and obtain a response from the _Camel_ service:
+
[source, subs=]
----
curl `kn route list -o jsonpath={.items[?(@.metadata.name==\"user\")].status.url}`/user | jq<br>
----
+
{blank}
+
The invocation should return the expected JSON payload.
+
--


{empty} +

[type=verification]
Did you see succeed to invoke the `user` service as an external consumer?

[type=verificationSuccess]
Well done !! make sure you follow the instructions below to clean your project.

[type=verificationFail]
Make sure your route is in place, and you force your browser to use HTTP with the `/user` path.

{empty} +

=== Clean up your project

When you're done playing in your _Developer Sandbox_, you can clean up your project (namespace) by un-deploying your _Camel K_ `user` integration by issuing the following command:

--
* {empty}
+
[source, subs=]
----
kamel delete user<br>
----
+
{blank}
+
or
+
* {empty}
+
[source, subs=]
----
oc delete integration user<br>
----
--

{empty} +

[type=verification]
Did you clean your sandbox project with the instructions above?

[type=verificationSuccess]
Well done !! Your namespace should be clean and ready for your next project.

[type=verificationFail]
Make sure your route was deleted, and your Camel K integration was removed.

{empty} +
